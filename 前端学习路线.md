# 前端学习路线

## 基础

### html

### css

#### flex布局

##### justify-content

###### 控制一组块在水平的布局

##### align-items

###### 控制一组块在垂直方向的布局

##### flex

###### 占一行的几份

#### table-cell布局

## 进阶

### js

#### DOM

##### 节点对象

#### BOM

##### 浏览器对象

#### ECM

##### 语法基础

###### 作用域链

####### 作用域类型

######## 全局作用域

######### 所有地方都能够访问,全局作用域变量太多容易造成全局变量污染

######## 局部作用域

######### 函数内部声明的变量,只有函数内部才能够访问

######## 块作用域(ES6)

######### if,for,while内部声明的变量,只有大括号内部能够访问

####### 产生

######## 一个变量或者函数声明是,作用域就已经生成

####### 作用域屏蔽

######## 当访问一个局部作用域和全局作用域都有相同名称的变量时,作用域有一个优先就近原则,即访问到最近的就停止了

###### 原型链

####### 任何对象都有一个__proto__对象,该对象指向生产自己的函数prototype

####### 任何函数都有一个prototype对象,该对象的constructor指向函数

####### 原型链的最顶层为null,也就是object的函数的原型的__proto__

###### this

####### 跟作用域链不同,this的指向在调用时生成,指向调用函数的对象

###### this绑定

####### 默认绑定

######## 直接调用函数时,this默认为window对象(严格模式下为undefined)

####### 隐式绑定

######## 当调用一个对象内部的函数时,该函数this指向该对象

####### 显示绑定

######## 使用call,apply,bind方法可以随便替换this指向

####### new绑定

######## new一个函数的时候,函数this指向生成出来的对象

###### new关键词

####### 1. 先创建一个空对象

####### 2. 给空对象的__proto__指向函数的prototype

####### 3. 然后给函数的this绑定给空对象

####### 4. 执行函数

#### ES6

##### 箭头函数

###### 函数调用都会有this对象生成,而箭头函数调用并不会生成this,所以箭头函数内部的this实际是通过作用域链找到的

##### 数组方法

###### map

####### 遍历整个数组,将return的值组成一个数组

###### filter

####### 遍历整个数组,根据return条件选择性返回一个新数组

###### forEach

####### 遍历整个数组,进行一些操作,没有return值

###### every

####### 只有数组内所有对象都符合条件才返回true 

###### some

####### 只要数组内有对象符合条件就返回true

###### reduce

####### 将数组内所有对象聚合起来

###### sort

####### 对数组内部的值根据返回正数负数排序

##### 变量声明关键字

###### const

####### 引用对象不可变,但是引用对象内部可变

###### let

####### 被声明的变量不提升,而且拥有块级作用域

##### 解构赋值

##### 类

###### 使用语法糖简化出一个类的创建

###### 结构

####### constructor

######## new一个类的时候会执行的方法,参数为new时候传进来的,在里面写代码首行需要写上super(arg)

####### static

######## 为函数局部变量

####### 函数或者变量

######## 为函数原型上的函数或者变量

##### 新对象

###### symbol

####### 创建的唯一的对象,任何值都不等同于他

###### set

####### 创建一个存储不可重复的列表

##### 迭代器

###### 可以遍历列表类型

##### promise

###### 解决回调的一个方案,创建时传入一个函数,该函数头两个参数为resolve和reject,函数内部逻辑成功执行调用resolve并把成功结果当参数传入,失败同上.使用的时候.then执行成功之后的逻辑,catch执行失败后的逻辑

##### 模块

###### import

###### export

###### export default

### JQuery

#### 一个JS库

## 框架

### vue

#### vue基础

##### 插值表达式

###### 在html里使用data里的值

##### v-on

###### 在标签属性上使用data里的值

##### v-bind

###### 给标签绑定方法

##### v-model双向绑定

###### 语法糖,监听输入框的改变事件继而改变data里的数据

##### method

###### vue页面调用的方法

##### compute

###### 可以监听到data数据的改变,从而返回一个新的数据,没有改变返回缓存,在html里使用同data

##### watch

###### 监听data数据改变,然后做出一些操作,异步

##### 生命周期

###### beforeCreate

####### 进行组件数组和方法初始化工作,此时data和method并未初始完成

###### created

####### data和method已经初始完成,但是el并没有初始化

###### beforeMount

####### el初始化完成

###### mounted

####### 组件已经成功挂载到el里

###### beforeUpdate

####### 更改data数据将要更新视图

###### updated

####### 已经更新视图

###### beforeDestory

####### 组件即将销毁

###### destoryed

####### 组件销毁

#### vue-router

##### vue官方的路由插件,用来使用vue项目的路由跳转

##### 标签跳转

###### router-link

##### 编程跳转

###### this.$router.push(url)

##### 匹配路由展示组件

###### router-view,全局顶层只有一个,其他都是子的

##### route,router,routes

###### route指的当前页面路由信息,可以获得路由参数

###### router指的是路由器,可以有push,go,replace等方法

###### routes指配置vueRouter的路由数组

##### 导航守卫

###### beforeEach

####### 进入下一个路由之前,进行判断此次跳转能够进入

###### afterEach

####### 切换路由之后,对切换的路由组件进行一些初始化操作

##### 路由对象

###### 一般路由对象是这样的 {
   url: '', // 映射路由
   redirect: '', // 重定向路由
   alias: '', // 映射路由别名
   name: '', // 映射路由名称
   meta: {}, 
   component: '', // 映射路由组件
   children: [] // 嵌套路由
}

##### 嵌套路由

###### 配置routes路由数组的时候,每个对象都有一个children数组,将路由对象写进数组中,那么所有children里的对象都是该路由对象的嵌套路由

##### 路由组件缓存

###### 用<keep-alive>包裹住<router-view>,展示的组件将不会因为路由切换而销毁,因此使用activated生命周期函数

#### vuex

##### 官方的vue状态管理插件,有modules,state,mutations,actions,getters概念

##### state

###### 类似于组件的data,全局状态

##### mutations

###### 类似于组件的method,改变全局状态,只能执行同步代码,使用store.commit()

##### actions

###### 用来执行mutation,进而改变全局状态,可以执行异步代码,使用store.dispath()

##### getters

###### 类似于组件的compute,对全局状态进行计算,被计算的状态没有改变就缓存返回,使用store.getters.xxx

##### modules

###### 上面的所有都可以作为一个module,进行分模块状态管理

#### elementUI

##### 饿了么出品的vue的后台组件库,直接现取拿来用

#### vue-cli

##### 官方的vue项目脚手架功能,能够帮助开发者一键生成vue项目需要的依赖,配置以及目录

### react

#### react基础

##### jsx

###### react对html,css这部分内容的书写不同于vue的分离,而是采用js来书写,因此这种格式叫做jsx

##### 使用变量

###### 在{}里可以访问变量

##### 绑定事件

###### 在标签属性上用on事件来绑定事件,需要主要this的指向问题(函数组件无需关心)

##### 组件创建方式

###### 函数组件

####### 使用函数来声明一个组件,最终return的是该组件的ui模块

###### 类组件

####### constructor

######## 组件的构造函数,用来初始化组件

####### render

######## 该组件需要渲染的ui模块

##### react-hook

###### react解决函数组件没有状态的方案

###### useState

####### 获取,更改函数的状态

###### useEffect

####### 当某些状态发生更改时自动执行的函数,函数内部return的函数会在组件销毁时执行

###### useRef

####### 用来创建dom引用

##### 生命周期

###### constructor

####### 只会执行一次,初始化的时候首先执行

###### render

####### 执行多次分别在初始化和更新时执行

###### componentDidMount

####### 当组件ui挂载到节点上时执行的函数

###### getDerivedStateFromProps

####### 当组件的props或者state发生更改时执行的函数

###### componentShouldUpdate

####### 组件状态发生更改时执行的函数,决定此次更改走不走render

###### componentDidUpdate

####### 组件状态发生更改并且render完执行的函数

###### componentWillUnmount

####### 组件即将卸载执行的函数

#### react-router

##### react的第三方路由插件,connect

#### react-redux

##### react的第三方状态管理插件,state,action,store

#### react-thunk

##### react状态管理的异步插件,允许返回一个函数而不仅仅是一个对象

#### antDesign

##### 蚂蚁金服出品的react后台组件库

#### antV react版的echarts,主要用来制作图

#### react-umi-dva 集成了router,reduce类似功能,直接上手

### angular

#### 没有学习

### axios

#### 封装了网络请求,能够对请求统一拦截

#### 比如发送请求前都要从localStorage中取得token,然后设置在本次请求头上

#### 比如接收到响应,对除了状态码200以外的进行细粒度处理(异常提醒,身份过期)

## css预编译器

### sass

### less

## 移动端

### 移动端适配

#### 主要是移动端像素和px比例转换问题,使用js+postcss可以完美解决

### 移动端事件

#### touchstart

#### touchmove

#### touchend

#### touchcancle

## 小程序

### 半vue半react

## 服务端

### node

#### 能够让JS脱离浏览器运行,内部移植了Chrome浏览器的V8引擎

### npm

#### node官方推出的一款包管理工具,解决了依赖问题,同时也是一个包仓库,允许开发者发布自己的包

#### 由于仓库是国外搭建的,所以速度缓慢而且很有下载依赖失败的情况

### tyarn

#### 是微软推出的一款多线程,缓存的包管理工具,速度十分快,仓库采用的是淘宝镜像源

### express

#### 经典的服务端框架,有些框架基于express

### koa2

#### 新一代的服务端框架,采用async await

### egg

#### 阿里内部使用的企业框架

## 打包编译测试

### webpack

#### 能够根据入口文件在内部构建一个程序依赖图,正确的将其打包输出一个或多个bundle文件

#### 配置结构

##### entry

###### 指定入口文件,可以是一个对象或者数组

##### ouput

###### 指定输出文件出口目录,文件名,文件引用的地址

##### resolve

###### 指定打包时将路径里根据某种规则匹配到的字符串替换成指定目录

##### loader

###### webpack只能识别js文件,当遇到css,图片,音频和视频时,需要loader将其转换一下再打包

##### plugin

###### 插件控制了整个打包的行为

##### mode

###### 设置当前打包环境为开发还是生产

### babel

#### babel是一个JavaScript编译器,能够把ES6以后语法的JavaScript代码编译成ES5之前的写法,以兼容所有浏览器并运行

#### 配置文件通常是项目根目录下的.babelrc

#### plugin

##### 插件通常代表一种语法转换规则,用来解析js代码将其根据规则转换,可以是一个数组或者字符串,数组的话第一个是plugin名,第二个是插件配置对象

#### preset

##### preset包含了一整套插件规则,避免了多次下载依赖混淆不清,结构同上

### post-css

#### 与sass,less等css预编译器不同,post-css是一款后编译器

#### 配置文件通常是项目根目录下的postcss-config.js

#### plugins

##### 每一款插件能够对css进行相应的转换

#### 常用插件

##### autoprefixer

###### 能够根据browserList查询到的浏览器集合,自动在需要的css属性前面加上浏览器前缀

##### postcssCssNext

###### 能够让最新的css写法兼容老版本浏览器,例如css变量,自动包含autoprefixer

##### cssnano

###### 能够压缩css文件

##### postcssImport

###### 能够把@import的css文件,直接把被引入的css内容写进引入的文件内

##### styleLint

###### 提供css规范检查

##### postcssModules

###### 能够让类名Id名不会重名

### jest

#### 为js提供一个测试环境,并且当出错时能够很好的给出错误上下文以给开发者纠错

#### 测试文件一般以xxx.test.js命名,然后命令行使用jest,即可测试

#### 测试命令

##### toBe

###### 精确匹配

##### not.toBe

###### 精确不匹配

##### toEqual

###### 匹配遍历对象的属性值

##### toBeCloseTo

###### 匹配小数

##### toMatch

###### 正则匹配

### 结合

#### 在webpack.config配置文件里的loader对象上写上规则,当遇到js文件就用babel-loader编译一下

#### 遇到css就用post-css-loader编译一下

## typescript

### 是JavaScript的超集,能够兼容ES6写法,变量声明需指定类型,否则无法通过编译

### 类型

#### 声明变量需要紧接在变量后面加上:类型

### 接口

#### 使用关键字interface声明一个接口类型,这样声明类型的时候可以使用接口类型

### 泛型

#### 当需要声明类型的类型是个数组,需要紧跟变量后面加上<类型>

### 枚举

#### enum关键词

## git

### 分布式代码管理协程工具

### 概念

#### 工作区

##### 被git管理到的所有文件

#### 暂存区

##### 被add进的文件

### add

#### 将指定改动的文件添加到暂存区

### commit

#### commit之后,会在当前版本前面创建一个版本,然后把当前版本指针指向新版本

### push

#### 将本地版本提交到远程仓库

### pull

#### 拉取远程仓库变化代码

### merge

#### 提交或者拉取的变化代码和本地改变代码文件是同一个,就要解决冲突

### branch

#### 一个仓库允许有多个分支,多个分支也运行合并成一个

### clone

#### 将地址上的远程仓库拷贝到本地上来

## 编码规范

### html中花括号,数组等首位不用空开

### js代码部分严格遵循符号首位空开

### 不要在js中写分号

### 根据功能写方法名
