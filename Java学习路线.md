# Java学习路线

## 基础

### 八大数据类型和包装类

#### 数据类型

##### byte

##### short

##### int

##### long

##### float

##### double

##### boolean

##### char

#### 包装类

##### Byte

##### Short

##### Integer

##### Long

##### Float

##### Double

##### Boolean

##### String

### 修饰符

#### 访问修饰符

##### default

###### 仅本包内的类可以访问

##### public

###### 任意包任意类都可以访问

##### private

###### 仅本类可以访问

##### protected

###### 本类和子孙类可以访问

#### 非访问修饰符

##### static

###### 静态变量

####### 变量不会随着对象生成再生成,整个程序独一份

###### 静态方法

####### 可以不用创建对象直接调用

##### final

###### final变量

####### 基本类型不可变,引用类型的引用对象不能更改,但是引用对象内的值可变

###### final方法

####### 方法不能被子类重写

###### final类

####### 类不能被继承

##### abstact

###### 被修饰的类不可以实例化,类内部可以包含抽象和非抽象方法还有成员变量

##### transient 

###### 序列化对象的时候,被修饰的变量会被忽略

##### synchronized

###### 方法

####### 锁住的是当前对象

###### 静态方法

####### 锁住的是当前类

###### 块

####### 锁住的是给的对象

##### volatile

###### 读

####### 每次读取被修饰的变量会直接从共享内存中取

###### 写

####### 每次对被修饰的变量进行操作都会强制刷新到共享内存中

### 循环

#### for

##### 起始操作,跳出条件,循环操作

#### while

##### 跳出条件

#### do while

##### 先操作,在判断,起码有一次执行

### 三目运算符

#### 判断条件 ? 正确要做的操作 : 错误要做的操作

### 泛型

#### 指定集合内部每个对象的类型

### 正则

#### 表达式匹配规则

### IO流

#### 输入流

##### 文件到内存的流

###### PrintInputStream

###### FileInputStream

###### ByteArrayInputStream

###### ZipInputStream

###### Reader

#### 输出流

##### 内存到文件的流

###### PrintOutputStream

###### FileOutputStream

###### ByteArrayOutputStream

###### ZipOutputStream

###### Writer

### 集合

#### Collecton

##### List

###### ArrayList

####### 底层是一个数组,所以查询快

###### LinkedList

####### 底层是一个双向链表,所以增删快

##### Set

###### HashSet

####### 内部维持一个HashMap,主要用到map的key,所以元素不能重复

#### Map

##### HashMap

###### 内部是一个数组,数组每个对象是一个链表,当链表达到一定长度变成红黑树

##### Hashtable

###### 操作同HashMap,只不过方法上都被加上synchronized

#### Collections

##### 是列表的工具类

## web

### jdbc

#### Java封装了对各种数据库的操作方法

### servlet

#### 响应客户端一个请求

### session

#### 存储在服务器上,会随着服务器关闭而消失

### cookie

#### 存储在客户端上,随着客户端存储策略而保存

### jsp

#### 本质上就是servlet,但是使响应网页更加方便

### Filter

#### 每个客户端请求到达servlet之前都将被filter处理决定是否放行

### Listener

#### 可以监听服务器启动和关闭执行相关操作

## 框架

### maven

#### jar包管理工具,可以让开发者更方便快捷管理依赖

### spring

#### IOC和AOP概念让开发者更方便

### spring mvc

#### 内部一个Dispatcher,封装了客户端请求服务端,服务端响应到客户端整个流程操作

### mybats

#### 封装了对数据库的操作,特点是手写sql

### hibernate

#### 封装了对数据库的操作,特点是不用手写sql,直接调用方法

### spring security

#### 项目的认证鉴权

### shiro

#### 比security体型更小的认证鉴权框架

### fastdfs

#### 文件存储,一般用阿里云存储

### 缓存

#### redis

##### 存储类型丰富,有aof和rdb持久策略,速度快

#### memcached

##### 存储类型单一,没有持久策略,速度十分快

#### mongodb

##### 存储json格式

### Elasticsearch

#### 搜索引擎

### nginx

#### 负载均衡,反向代理,动静分离

### 消息队列

#### RabbitMQ

##### erlang语言写的,有exchange,route概念

#### RocketMQ

#### Kafaka

##### 大数据必备

### 定时任务

#### springTask

##### 可以理解为轻量级的quartz,配置简单,默认执行的线程池为1,所以多个定时任务同时执行的话为串行执行

#### quartz

##### 配置略微复杂,默认多线程执行

## 微服务

### 服务注册发现中心

#### eureka

#### nacos

### 服务调用

#### dubbo

#### feign

### 网关

#### zuul

#### gateway

### 配置中心

#### nacos

#### config

### 链路追踪

#### zipkin + sleuth

### 服务熔断降级

#### hystrix

#### sentinel

### 分布式事务

#### tcc

#### seta

## JVM

### 内存模型

#### 线程共享

##### 方法区

###### 存储类信息,静态变量,运行常量池,静态常量池

##### 堆

###### 存储对象,字符串常量池

#### 线程独享

##### 程序计数器

###### 记录当前线程执行位置

##### 虚拟机栈

###### 包含一个个栈帧,每个栈帧有局部变量表,方法出口,操作数栈,动态链接

##### 本地方法区

###### 和虚拟机栈类似,但是是为native方法服务

### 类加载

#### 加载时机

##### 主动引用(初始化)

###### 1. 使用new关键字创建对象

###### 2. 对类使用反射

###### 3.  启动mian方法所在的类

###### 4.  当初始化一个类,他的父类没有初始化时,会先初始化父类

##### 被动引用(初始化之前)

###### 1. 通过类名获取class

###### 2. 通过Class.forName 指定initialize为false

###### 3. 使用类的静态常量(final) 

#### 双亲委派机制

##### 当类加载器加载一个类时,首先交给自己的父类加载器加载,如果父类找不到,再交给下一级加载器加载

##### 优点

###### 1. 避免了同一个类被多次加载,影响性能

###### 2. 避免了核心包里的类被篡改替换

#### 加载过程

##### 载入

###### 通过类的全限定名讲类加载到内存中,并将类信息存储在方法区

##### 连接

###### 验证

####### 验证类符合虚拟机要求,并且确保不会危害虚拟机安全

###### 准备

####### 为类的静态变量赋上类型默认值,对final修饰的静态变量赋值,存储在方法区内

###### 解析

####### 将类的符号引用(对象引用的字面量)转成直接引用(对象在堆中的地址)

##### 初始化

###### 正确的为静态变量赋初始值,然后执行静态代码块(只有对类的主动引用才会触发这一过程)

## 并发

### 并发的性质

#### 内存可见性

##### 一个线程对共享资源的修改,其他线程能够访问

#### 原子性

##### 一个线程内的所有操作都应当做一个整体,要么都执行,要么全都不执行

#### 有序性

##### 线程内的代码要按照编码顺序执行

### 工具类

#### CountDownLatch

##### 计数器

###### 通过构造器指定计数器的线程数量,当线程运行数量达到指定数量,就运行当前线程代码

#### Semaphore

##### 信号量

###### 通过构造器指定线程同时运行数量,线程内执行代码前先acquire一下

#### CyclicBarrier

##### 循环栅栏

###### 和计数器类似,但是可以循环利用,并且到达数量之后要运行的代码要放在回调中

### 并发结构

#### CopyOnWriteArrayList

#### CopyOnWriteArraySet

#### ConcurrentHashMap

#### ConcurrentLinkedQueue

#### ConcurrentLinkedDeQueue

### CAS

#### Compare And Swap,比较并交换,通过自旋(循环)的方式安全的更改一个值

#### 成功应用

##### AtomicInteger

##### AtomicBoolean

##### AtomicLong

##### ...

#### 缺点

##### 会造成ABA问题,就是这个值开始是A,但在中间发生了一次改变,值变成B,最后又变成A了,这时候CAS辨别不出

### AQS

#### AbstractQueuedSynchronizer的简称,内部维护了一个被volatile修饰的且初始值为0的int变量

#### 当锁为互斥锁,有线程获取到锁时将state=1,释放归0,当前线程多次获取锁,state加一,只有为0其他线程才能获取

#### 当锁为读写锁,有线程获取到锁将锁加一,并要求所有线程释放锁时,state最终归零

#### 是所有代码层锁的顶层抽象类,它规定了如何获取释放锁,还有利用Condition判断锁状态

### 锁

#### synchronized

##### 系统关键字,能够根据情况实现锁升级,无锁->偏向锁->轻量锁->重量锁,但是不能降级

#### ReentrantLock

##### 通过AQS实现的互斥锁

#### ReentrantReadWriteLock

##### 通过AQS实现的读写锁

#### 锁种类

##### 互斥锁(独占锁)

###### 只有一个线程能够持有锁

##### 读写锁(共享锁)

###### 可允许多个线程持有锁

##### 可重入锁

###### 单个线程允许多次获取同一把锁

##### 公平锁

###### 根据阻塞的顺序依次获取

##### 非公平锁

###### 不会按照阻塞顺序获取,允许加塞

##### 乐观锁

###### 操作的时候不会锁住资源,但是依靠版本号

##### 悲观锁

###### 操作的时候锁住资源

##### 分段锁

###### ConcurrentHashMap使用的技术,将一个链表上的数据分段,当操作某段数据的时候,该段上锁,其他段不上锁

##### 自旋锁

###### 操作的时候不会切换上下文,而已采用循环方式一直等待可执行

### 关键字

#### volatile

##### 能够保证内存可见性,有序性,但是无法保证原子性

### 线程

#### 运行状态

##### 创建

###### new一个线程对象

##### 就绪

###### 调用线程对象的start方法

##### 运行

###### 获取到锁,被CPU调度

##### 阻塞

###### 交出锁

####### 调用await方法

###### 不交出锁

####### 调用sleep方法,或者join方法

##### 死亡

###### 线程的方法执行完毕或者抛出异常

#### 创建方式

##### 继承Thread

##### 实现Runnable

##### 实现Calleable

#### 线程池

##### 实现ExecutorService接口的对象

##### Executors是JDK自带的线程池工具类,内部维持了一个ThreadPoolExecutor

##### ThreadPoolExecutor的核心参数

###### corePoolSize

####### 指定线程池的核心线程数

###### maximumPoolSize

####### 指定线程池的最大线程数

###### keepAliveTime

####### 指定超出核心线程数的线程保存时间

###### TimeUnit

####### 时间的单位

###### BlockingQueue<Runnable>

####### 存储线程的队列对象

###### threadFactory

####### 创建线程的工厂

###### RejectedExecutionHandler

####### 当线程超出最大线程数的拒绝策略

## 算法

## 设计模式(23)

### 创建型

#### 工厂方法

#### 抽象工厂

#### 原型

#### 单例

#### 建造者

### 结构型

#### 适配器

#### 组合

#### 桥接

#### 代理

#### 装饰器

#### 享元

#### 外观

### 行为型

#### 责任链

#### 策略

#### 观察者

#### 访问者

#### 模板

#### 解释器

#### 备忘录

#### 状态

#### 中介

#### 迭代器

#### 命令

## 数据库(MySql)

### 结构

#### 客户端

##### 请求与数据库建立连接,发送执行sql语句

#### 服务端

##### 连接器

###### 管理连接,权限校验

##### 查询缓存

###### 先去内存中查找缓存,找到直接返回

##### 分析器

###### 词法分析,语法分析

##### 优化器

###### 生成执行计划,选择索引

##### 执行器

###### 操作引擎,返回结果

#### 存储引擎

##### 每个存储引擎各有不同

### 引擎

#### MyIsam

##### 优点

###### 查找十分迅速

##### 缺点

###### 缺少事务,使用表锁

##### 使用的是非聚簇索引,索引上只保存数据的引用

#### InnoDb

##### 优点

###### 拥有事务,使用行锁

##### 缺点

###### 不支持外键

##### 使用的是聚簇索引,表数据放在所以叶子节点上,所以要求必须要有唯一索引,创建表时不指定mysql会默认创建

#### Memery

### 索引

#### Mysql支持HASH，BTREE，RTREE等多种类型索引

#### 索引类型

##### 1.普通索引

###### 最基本的索引,设置没有任何限制

##### 2.唯一索引

###### 和普通索引类似,但是要求被索引的字段在表中唯一,允许有空值,如果是组合索引,那么两个字段在表中唯一

##### 3.主键索引

###### 特殊的唯一索引,不允许为空值,一般为id

##### 4.组合索引

###### 将多个字段组合成一个索引,使用组合索引查询时,要遵循最左前缀原则

##### 5.全文索引

###### 专门对一段文字的关键字进行搜索,而不是简单比较和模糊匹配

#### 口诀

##### 全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上不计算，范围之后全失效；
莱克百分写最左，覆盖索引不写星；
不等空值还有噢，索引失效要少用。

#### 索引失效

##### 不正确的操作导致索引没有使用到,转而变成全表检索,一行一行查找

#### explain

##### 用来分析执行语句索引使用情况

#### 优点

##### 方便数据库更快的定位到数据行所在位置

#### 缺点

##### 建立过多索引会让插入更新操作变得缓慢

### ACID

#### Atomic(原子性) 

##### 规定一个事务内的操作,要么全部执行,要么都不执行

#### Consistency(一致性)

##### 事务执行后,数据是合法状态,只有保证了aid,一致性才能得到保证

#### Isolation(隔离性)

##### 多个事务并发操作,事务间互相隔离

#### Durability(持久性)

##### 事务操作一旦执行,数据将永久改变

### 事务隔离级别

#### read uncommitted(读未提交)

##### 能够读取到其他未提交事务中更改的数据,脏读

#### read committed(读已提交)

##### 只能读取到其他已提交事务中更改的数据,不可重复读

#### repeatable read(可重复读)

##### 能够重复读取到其他已提交事务中更改的数据且数据不会改变,幻读

#### serializable(序列化)

##### 读取的时候其他连接不能更改表数据,只能等待操作完成
